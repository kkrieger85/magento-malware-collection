#!/usr/bin/env python3

"""
   magento-malware-scanner.py, 
        a wrapper around Yara to efficiently detect malware code in 
        Magento installations.
   
   Copyright (C) 2017 Willem de Groot <gwillem@gmail.com>

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.
   
   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
   
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301  USA

"""

import os
import re
import sys
import argparse
import logging
import hashlib
import json
 
try:
    import yara
except ImportError:
    logging.warning("You need to install python(3)-yara. Try one of these\n\n"
          "\tsudo apt-get install python-yara\n"
          "\tsudo pip install yara")
    sys.exit(1)

try:
    import psutil
except ImportError:
    psutil = None
    logging.warning("Missing psutil, not adjusting IO priority.")

LAST_RUN_FILE = '.magento-malware-scanner-last-run'
YARA_RULES_FILE = os.path.expanduser('~/.magento-malware-scanner.yar')
CODE_EXT = ('php', 'phtml', 'js', 'jsx', 'html', 'php3', 'php4', 'php5', 'php7', 'sh')


def parse_args():
    parser = argparse.ArgumentParser(
        formatter_class=argparse.ArgumentDefaultsHelpFormatter,
        description="Scan for hidden malware.",
    )
    parser.add_argument('path', help='File or dir to scan.')
    parser.add_argument('-r', '--rules', help='Yara rules file.', default=YARA_RULES_FILE)
    parser.add_argument('-n', '--newonly', help='Only consider files that were modified/created since last succesful run. To maintain state, I will create a {} file under the given path.'.format(LAST_RUN_FILE), action='store_true')
    parser.add_argument('-d', '--deep', help='Scan all files, not just code.')
    parser.add_argument('-v', '--verbose', help='Verbose mode.')

    args = parser.parse_args()

    if args.newonly and not os.path.isdir(args.path):
        logging.error('I can only use --newonly on a directory!')
        sys.exit(1)

    if not os.path.exists(args.path):
        logging.error('{} does not exist!'.format(args.path))
        sys.exit(1)

    if args.deep:
        args.req_ext = []
    else:
        args.req_ext = CODE_EXT

    if not os.path.isfile(args.rules):
        print("Rules file {} does not exist. Use --rules <path>".format(args.rules))
        sys.exit(1)

    if args.newonly:
        args.newer_than = find_last_run_timestamp(args.path)
    else:
        args.newer_than = None

    return args


def find_last_run_timestamp(path):
    fname = os.path.join(path, LAST_RUN_FILE)

    if not os.path.isdir(path):
        return None

    if not os.path.isfile(fname):
        return None

    return os.path.getmtime(path)


def write_last_run_timestamp(path):
    fname = os.path.join(path, LAST_RUN_FILE)

    if os.path.exists(fname):
        os.unlink(fname)

    return open(fname, 'a').close()



def find_targets(root_path, newer_than=None, req_ext=None):
    """
     Produce an iterator for all the relevant files recursively found under root_path.
     If root_path is a file, return an iterator with just that.
     Param ignore_older_than is an epoch timestamp from os.path.getmtime()
    """

    if os.path.isfile(root_path):
        yield root_path

    if not os.path.isdir(root_path):
        raise RuntimeError("%s is not a file or directory" % root_path)

    for root, dirs, files in os.walk(root_path):
        for myfile in files:
            path = os.path.join(root, myfile)

            if req_ext is not None:
                if all([not myfile.endswith('.' + x) for x in req_ext]):
                    continue

            if newer_than is not None:
                if os.path.getmtime(path) < newer_than:
                    continue

            yield path


def load_rules(path):
    with open(path) as fh:
        rawrules = fh.read()

    # Find whitelist hashes from comments, because yara whitelist
    # hashing is too slow.
    m = re.search('/\*[^*]*WHITELIST = (\[.+?\])\s*\*/', rawrules, flags=re.DOTALL)
    whitelist = set(json.loads(m.group(1)) if m else [])

    rules = yara.compile(source=rawrules)

    return rules, whitelist


def main():
    args = parse_args()

    # don't swamp the machine
    if psutil:
        mylife = psutil.Process()
        mylife.ionice(psutil.IOPRIO_CLASS_IDLE)

    rules, whitelist = load_rules(args.rules)

    try:
        num_files = 0
        all_files = find_targets(args.path, 
                                 newer_than=args.newer_than,
                                 req_ext=args.req_ext)

        for path in all_files:
            num_files += 1
            with open(path, 'rb') as fh:
                data = fh.read()

            sha1sum = hashlib.sha1(data).hexdigest()
            if sha1sum in whitelist:
                print("{} whitelisted".format(path))
                continue

            matches = rules.match(data=data)
            for m in matches:
                print(m, path)
        
        if args.newonly:
            write_last_run_timestamp(args.path)

    except KeyboardInterrupt:
        pass

    print("Finished scanning {} files.".format(num_files))


if __name__ == '__main__':
    sys.exit(main())
